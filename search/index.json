[["Polygonal Terrain Generation","2021Âπ¥11Êúà11Êó•","/2021/11/19/polygonal-terrain-generation.html/","This project is based on: http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ Couple days ago, I came across this interesting article called \u0026ldquo;Polygonal Map Generation for Games\u0026rdquo;. At first glance, I wasn\u0026rsquo;t entirely interested, as I mostly generate my terrain using perlin noise. This is a much easier implementation - Unity\u0026rsquo;s Math library officially supports perlin noise, making it easier for Unity users to implement perlin noise based terrains. However, the maps generated by perlin noise aren\u0026rsquo;t entirely good for creating island maps. Sure, there is a workaround for it, but it\u0026rsquo;s always hard to get an island looking map just by using perlin noise. They often end up less realistic maps that look like a noise if seen from the top view. Otherwise, if the map has a fixed size in general, polygonal map generation would work much better. There will always be just one mountain where player can go on top of, unlike the noise function. A voronoi diagram has been calculated using csDelaunay library (https://github.com/PouletFrit/csDelaunay) . When you pick random points and generate Voronoi polygons, the maps tend to look very irregular. These irregular polygons are definitely not what we want for a terrain. If maps were generated directly using the edges would look rough. This is where the Lloyd\u0026rsquo;s algorithm and relaxation comes in. Using multiple relaxation iterations, we can make the voronoi polygon map a lot more smoother and distribute the polygons evenly. Therefore, making the map look smoother. During the map data generation, the following information needs to be calculated: adjacent polygon (neighbor cells), edges, island. Using these information, elevation of the terrain as well as the biome can be calculated. Once the island coast has been generated, we can fill the selected island with land, others with water. Calculating the elevation is quite easy (compared to perlin noise), as I just took the distance of a cell from the coast and used that information for elevation. So the center cell of the whole island would have the highest elevation. Finally, the data goes through a so-called \u0026ldquo;Elevation Curve\u0026rdquo;, which lowers the lower part of the terrain further more, while making elevated terrains even more elevated. A flat curve (constant 1) would make a minimal difference between the lower part and the higher part of the terrain. Elevation Curve Once all the data has been generated, it was all about generating the mesh (with mesh colliders), translating the generated data to a texture then assigning the texture to the mesh. Except, I had to create the height map for the mesh separately (in float[,] variable), so that I could assign this variable to the terrain mesh directly. You might notice that the generated map looks a little bit \u0026ldquo;pixelated\u0026rdquo;. This is because Unity has a limit on how many vertices one mesh object can have. It\u0026rsquo;s generally not a good practice have a lot of vertices on a single mesh. A workaround for this would be separating the terrain mesh into different parts (in this case, into 4 smaller mesh objects) and connecting them together. Similar to Minecraft\u0026rsquo;s implementation of chunks. This would also allow me to put multiple islands together. Terrain\u0026rsquo;s texture size in the pictures below have 200x200. Terrain textures bigger than this would exceed the maximum allowed number of verticies on the mesh. Generated Map Generated Map2 Generated Map3 I\u0026rsquo;m happy with the end result, but its performance is not as good as if I were to generate using perlin noise. If I were to make a full map using this method of terrain generation (multiple islands), it would definitely be much harder for computers. To be fair, all of the calculations are done on a single thread, meaning the calculations that I\u0026rsquo;ve performed was only done on a single core of a processor. Multi-threaded calculations would definitely be a lot better for the performance. "],["Mesh Simplification using Quadric Error Metrics","2021Âπ¥10Êúà10Êó•","/2021/10/11/mesh-simplification-using-quadric-error-metrics.html/","This time, I\u0026rsquo;ve done a quick and short research on mesh simplification algorithm (and homogeneous coordiantes, quadrics) using quadric error metrics (and planning on implementing this algorithm with Unity Engine). Be aware that not all of this information may be correct. Homogeneous coordinates (projective coordinates) railroad; source: https://www.songho.ca/math/homogeneous/homogeneous.html In contrast to Euclidean geometry (three-dimensional space), projective geometry introduces another Z dimension, called W, in which it is used to describe the distance from the projector to the screen. In order to correctly convert a 3D coordinate into a 4D coordinate without modifying any property, one should always set W = 1. Doing this has no effect on the X, Y or Z values. In other words, if one renders coordinates with W \u0026gt; 1, everything would look small; W \u0026lt; 1 everything would look too big. Furthermore W = 0 would result in a divide by zero error. Despite it being 4D vectors similar to quaternions, homogeneous coordinates have different concepts with different use cases. In much simpler terms: two parallel lines can intersect each other in projective space (seen from the railroad model). In computer graphics, utilizing homogeneous coordinates allows common operations such as translation (‚Äúmove‚Äù), rotation and scaling. Quadrics Quadrics are defined by quadratic equations (second-degree equations) in two dimensional spaces and many common shapes (e.g. spheres, ellipsoids, tori, paraboloids and hyperboloids) can be modeled with quadrics. E.g. spheres generally have a quadratic equation of: x2 + y2 + z2 = rz Surface simplification general goals By simplifying a mesh, it allows for an implementation of various LODs (level of details) in computer graphics. The ultimate goal in doing this is to preserve computing resources, as such complex models are not always required to display adequate level of realism. Albeit the simplification may occur, the quality of a simplified mesh should not differ too much from the original source, as the primary goal in computer graphics application is to maintain a convincing level of realism most of the time. This process should be done by taking a polygonal model as input and generate a simplified model as output. In 3D graphics, 3 dimensional models or meshes / polygon meshes consist of vertices, edges and faces. The achievement should be to have less vertices / edges / faces. Edge contraction edge contraction; source: https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf Iterative edge contraction is an algorithm, in which it stands for the foundation for quadric error metrics surface simplification. The idea of this algorithm is to take a pair of vertices (v1 and v2; edge) and contract to just one single vertex. Non-edge contractions will join non-edge pairs together. This operator, however, may result in concerning topology results (e.g. unacceptable fragmentation). The matter isn‚Äôt as significant in applications such as rendering. Other relevant algorithms include: vertex decimation and vertex clustering. Optimal pair selection In order to apply an iterative edge contraction algorithm appropriately, a valid vertex pair must be selected. A pair (v1, v2) is a valid pair for contraction if either: (v1, v2) is an edge or ||v1 - v2|| \u0026lt; t, where t is a threshold parameter If t = 0, then only the actual edges of the mesh will be selected as a valid pair. Higher thresholds allow non-connected vertices to be paired. Quadric error In order to perform the contraction to a selected optimal pair, an optimal position of the vertex must also be determined. Defined is ‚Äúoverall error‚Äù between M0 (input mesh) and Mr (resulting mesh; simplified mesh) as a function of ùö´(v). A simple scheme to locate the best position is to select either the positions of v1, v2 or (v1 - v2)/2, depending on which one of these produces the lowest value of ùö´(v). Although, finding a position of vertex with the minimum value of ùö´(v) is most ideal. Measuring error with quadrics Meshes consist of triangles (three vertices make up to a triangle); One vertex v1 can be associated with many triangles. These triangles can be expressed as a plane. By using cross products, the normal vector of this plane can be calculated, ergo the plane equation. The plane equation is ax + by + cz + d = 0 where a2 + b2 + c2 = 1 (normalized normal vector). Measurement of error with quadrics can be done by computing the sum of squared distance of a vertex v1 to its associated planes. This can be interpreted as 4x4 matrix multiplication (with v1 being a homogeneous vector (x, y, z, 1); w component/Euclidian distance) = 1). Optimal position for v can be calculated based on the minimal value of this measurement (which would also result in a minimal value of ùö´(v)). One can stop the algorithm once the mesh has reached a certain amount of vertex count. With that being said, I\u0026rsquo;m still not entirely certain about the math behind the entire algorithm. Read more about the algorithm here: https://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf Now here\u0026rsquo;s the implementation in Unity: WIP "],["Scattered","2020Âπ¥09Êúà09Êó•","/2020/09/18/scattered.html/","For only 5 days, I worked on an entry for \u0026ldquo;Dani\u0026rsquo;s basement Jam\u0026rdquo; (https://itch.io/jam/danis-discord-server-jam) . Total 93 entries were made to this game jam and 711 ratings in total. This game jam is hosted by a YouTuber called Dani. As he didn\u0026rsquo;t publicly announce this game jam on his YouTube channel, there weren\u0026rsquo;t a lot of participants. I used Unity game engine to make Scattered. For pixel arts and animations, I used Piskel. I\u0026rsquo;m really happy about how the art style of the game turned out. Reading the comments that were made to my entry, it seems like everyone liked the art style too. I actually placed #2 overall in this game jam. In fact, #1 in art and sound/music. I didn\u0026rsquo;t actually make the music (and I did state this in the submission), but I did make my own sound effects. I recorded them using my mic and edited them on Audacity. Sonud effects are made by either my mouth or playing around with different objects. The following YouTube video explains how the submission went: "],["Replay","2020Âπ¥08Êúà08Êó•","/2020/08/13/replay.html/","For the past two weeks, I worked on an entry for \u0026ldquo;Brackeys Game Jam 2020.2\u0026rdquo; (https://itch.io/jam/brackeys-4) . This is a bigger game jam that\u0026rsquo;s hosted by a YouTuber named \u0026ldquo;Brackeys\u0026rdquo;. I used Unity game engine to make a game in two weeks based on an announced theme, \u0026ldquo;Rewind\u0026rdquo;. The following YouTube video explains how the submission went:"],["Protect The Sandcastle","2020Âπ¥06Êúà06Êó•","/2020/06/10/protect-the-sandcastle.html/","For the past two weeks, I worked on an entry for \u0026ldquo;I Can\u0026rsquo;t Draw But Want To Make A Game\u0026rdquo; game jam. This game jam mainly targets people who want to make a game and submit it to the game jam, but don\u0026rsquo;t have good ability to draw. I decided to join this game jam, as I myself isn\u0026rsquo;t a good artist and I just found this game jam to be interesting. Game jam is basically a competition where you have to make a game in limited time based on a theme that\u0026rsquo;s given by the moderator. Here\u0026rsquo;s how it went for me (youtube video): This is my itch.io page (entry): https://foorfootstudios.itch.io/protect-the-sandcastle "],["Progression","2020Âπ¥02Êúà02Êó•","/2020/02/17/progression.html/","Progression is an Android game made with Unity that I recently released on Google Play store (that is still downloadable on Google play, link to the download at the bottom). It didn\u0026rsquo;t take me a long time for me to develop this game as the whole system was very easy to implement. The main point of this development was to make a simple game in a short duration just so I can get more motivated and get the Unity development wheels rolling again, as I took a break after finishing Sketch Hero. Main menu Progression is a simple arcade shooter. There are a total of 75 waves (originally 50, but I got requested to make more levels, as they were too \u0026ldquo;easy\u0026rdquo; to complete), and the goal of the game is to defeat all the enemies that spawn in each wave and reach 75 waves. The difficulty of the wave progress as it gets higher and the player needs to destroy them all by progressing them. Kind of like an RPG game, except the options, are limited. The player can upgrade their character by an in-game shop which they can use with in-game money they earn by destroying enemies in the game. Another option for an upgrade is picking up \u0026ldquo;upgrade\u0026rdquo; items within the match. This gives the player a more significant upgrade, but this effect is gone once the player exits the match. It is near impossible for a player to complete the game in the first match. The whole concept was to grow their character throughout different matches and upgrade their character using the money they earn. I originally designed this game to be extremely difficult to complete. I had a hard time balancing each enemy\u0026rsquo;s ability in the match. I should plan out all the features of the game as well as the enemy\u0026rsquo;s stats before I make them. I didn\u0026rsquo;t genuinely spend a lot of time planning the game before I develop, unlike the other ones, because back then I thought the development process would only take 3 - 4 weeks (I finished all the core mechanics within 2 weeks, but the polishing and fixing bugs took longer). I used the object pooling system to spawn different enemies and sort of \u0026ldquo;recycle\u0026rdquo; them when they died. Because the platform I was targeting was Android, optimization was mandatory for this project as well. I couldn\u0026rsquo;t just instantiate (spawn) a new object whenever the enemy spawns or destroy an enemy object completely. The code that gets ran in the background when initialized, destroyed would degrade the performance too much. I faced a problem, however. Because I was using an object pooling system, there had to be enough enemies spawned beforehand. This means that, if I want to spawn 30 A enemies in a match, I need to have 30 A enemies in the beginning of the game. This might sound a bit silly and obvious, but here\u0026rsquo;s the problem: I didn\u0026rsquo;t want to fill the wave up with the same type of enemy. So I made different types of enemies (I used different shapes so like: square, hexagon, circle, etc.). Now let\u0026rsquo;s say I want to spawn 30 enemies in total, but I want to randomly select enemies between square and circle. Meaning some enemies from total enemies spawned are square while others are circle. Because this is all handled randomly there are a tiny odd that only square enemy can spawn. This means that I would need 30 square enemies in the pool to fill up the match with 30 square enemies (requested). This might not be that big of a problem, but what if I want to add more enemies in a wave and more variety of enemy types? I would need to spawn in so many enemies in so many different types beforehand and at some point, the object pooling system wouldn\u0026rsquo;t just work. One solution that I found was to check if the enemy is not available (\u0026ldquo;sold out\u0026rdquo;, there are no enemies left in object pool to spawn) and if not, spawn a different enemy. Unfortunately, I ended up not using this method, because the code was just getting too messy and I just didn\u0026rsquo;t want to touch it any further. I concluded with a dirty way of handling this which was just spawning a bunch of enemies beforehand and HOPING it wouldn\u0026rsquo;t result in such odd that enemy type won\u0026rsquo;t get \u0026ldquo;sold out\u0026rdquo;. I didn\u0026rsquo;t bother with the UI that much. UI could\u0026rsquo;ve improved by A LOT in multiple aspects\u0026hellip; Upgrade menu Something that I enjoyed making during the development was boss fights. It was the first time for me to make bosses, so I wasn\u0026rsquo;t sure how I should start. Turned out to be easier and better than I thought/expected. Although, I wouldn\u0026rsquo;t say I\u0026rsquo;m 100% satisfied with the product. There are things that I want to improve/could\u0026rsquo;ve improved on. Bossfight I also added ads (supported by Unity) for this game. I didn\u0026rsquo;t expect to make money from it at all (in fact, I didn\u0026rsquo;t \u0026ldquo;make\u0026rdquo; any. I got around 3 dollars USD by ads, but I couldn\u0026rsquo;t withdraw it since the withdrawal process is only allowed once you earn more than 100 dollars USD. That\u0026rsquo;s how Unity ad system works I guess\u0026hellip;) but I just wanted to try and see how it works. Turned out to be easier than I was expecting. I undoubtedly realized how important the whole planning procedure was throughout this project. Not only I could\u0026rsquo;ve avoided a lot of bugs that happened just because I wasn\u0026rsquo;t thinking about it enough (like the enemy spawning issue I addressed earlier in the post), but also saved a lot of time. This project might have finished under a month if I had done proper planning. I don\u0026rsquo;t want to touch on this project any further just because I didn\u0026rsquo;t plan on working on it once I\u0026rsquo;m done. Not only that, due to the lacking planning I did, I just don\u0026rsquo;t want to go over it anymore. As I mentioned, it only took around 3 - 4 months in total to create this game from scratch, all the way to polishing. Sure, the game could\u0026rsquo;ve been made in a shorter period, just because of how simple it is, but I was bothered by other more important priorities of my life when I was developing. This might sound like an excuse (which I\u0026rsquo;m not denying) but I could only work on the game for around 5 hours per week. But to be honest, overall the game could\u0026rsquo;ve improved in a lot of different ways. I feel like I wasn\u0026rsquo;t giving my best for this project. I\u0026rsquo;m going to spend more time polishing and finishing the game better next time. Here are some gameplay screenshots: Gameplay Gameplay2 Gameplay3 Download Link: https://play.google.com/store/apps/details?id=com.FourFootGames.Progression "],["One Room Survival","2019Âπ¥09Êúà09Êó•","/2019/09/18/one-room-survival.html/","\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; One Room Survival is a game that I started making after I published Sketch Hero. After careful consideration, I decided to make a PC game. Possibly also port it to Android, if the impressions of the game are good. Something that I had to consider while planning the project was marketing. In the beginning, I also had no idea where to exactly publish my game. Steam, a huge game \u0026ldquo;store\u0026rdquo;, which is commonly used by most of the gamers, was not an option for me personally, as I couldn\u0026rsquo;t pay for the fee that\u0026rsquo;s required for me to publish the game on Steam. I came across gamejolt and itch.io. They\u0026rsquo;re both game stores that are less popular to gamers, but still very popular. Games on those websites are usually made by indie developers, as developers are allowed to publish their game for free without an additional fee. You can also sell/buy games here as well. I ended up with itch.io, just because it was a bit more user-friendly and a bit more popular among the gaming community. Sad part is that this projected ended and the game didn\u0026rsquo;t even see the light. One Room Survival game is as the title suggests, you must survive in one room with limited resources. Player gets daily food supply with a little bit of water, but you can only get so much that you will soon starve to death. Player must find a way to escape the room and/or survive the longest possible. The rough story idea is that the player needs to dig a cave and make an escape path. Digging a cave/going mining reduces player\u0026rsquo;s health and makes him hungry/dehydrated quicker. Player needs to carefully decide when to go mining and how long he should mine. That was the whole concept of the game. The project wasn\u0026rsquo;t too big, it was planned with Trello and google docs and it was just generally good and well set up. I don\u0026rsquo;t have a lot of screenshots to show: 1. it\u0026rsquo;s one room survival game, you only interact in one room. 2. I stopped working on the game before making bigger progress. Two things that I particularly wanted to focus on during the development were lighting/environment settings and UI. In my last couple 3D projects, such as Awaken Sentinel (3D multiplayer FPS game), I didn\u0026rsquo;t focus on the scene lighting and the mood of it rather focused on the post-processing effects and how the camera renders the scene. There\u0026rsquo;s a difference between how the camera renders (post-processing) the scene and how the scene looks like (lighting/environment setup). I consider how the scene looks far more important than how the camera renders now. Of course, adding post-processing effects does help the mood you want to go for, but I feel like it\u0026rsquo;s a bit more natural if you\u0026rsquo;re adjusting the whole scene lighting. I baked the lighting using the \u0026ldquo;Progressive GPU\u0026rdquo; option in Unity. I did not use real-time lighting at all. I thought real-time lighting would unnecessarily take performance when all the scene objects are stationary (you can only bake lighting if the models are not going to move during the game. real-time lighting is usually used for things like characters, so objects that move during the game). Baking lighting simply means making an image, that can be projected on the objects in the scene to simulate that there are things like shadows in the scene. I used fake shadows for the character. It is possible to mix baked and real-time lighting, but I liked the look of the fake shadows (just a \u0026ldquo;circle\u0026rdquo; on where the character is standing) more for this game. However, I did use real-time shadows for the objects that can be picked up by the player. This was the only solution, as baked shadows are always there, projected on the room, even the object is not visible to the camera. For the lights, I applied emissive material on the cylinder (light bulb). No directional/environmental lights were used. I would like to specifically point out that I baked ambient occlusion, as on my other projects, I\u0026rsquo;ve been using screen space ambient occlusion instead. Screen space ambient occlusion (SSAO) is a post-processing effect, which is used on the rendering camera to \u0026ldquo;simulate\u0026rdquo; the ambient occlusion of the environment. This is less realistic and very performance heavy as it needs to calculate where the proper shadow needs to be. In case you don\u0026rsquo;t know what ambient occlusion is, it\u0026rsquo;s a shadow/darker part that\u0026rsquo;s between two objects when they collide together Here\u0026rsquo;s how it turned out: Gameplay Sceneview Character model is missing. This is due to incompatibility. Unity updated itself so much that some file extensions are not readable/compatible. I\u0026rsquo;m writing this from the future. As I mentioned, I also focused on UI this game. I didn\u0026rsquo;t spend a lot of time tinkering the whole Unity UI system or properly design UI on my other games, so I wanted to try something new for this project. It obviously didn\u0026rsquo;t turn out to be the best and I know I can improve a lot, but here\u0026rsquo;s how it is: Gameplay2 Something that I\u0026rsquo;m proud of is the pickup system. Player can interact with the object in the room and pick them up if they want to. Player is also able to use them if they are usable. "],["Arduino Smartwatch","2019Âπ¥03Êúà03Êó•","/2019/03/25/arduino-smartwatch.html/","\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; For the past 2 weeks, I\u0026rsquo;ve been working on a smartwatch project using my Arduino Pro Mini 3.3v (ATMEGA328P @ 8Mhz). My intention is my smartwatch will connect to my phone and receive all the useful information such as time, notification and messages. Because it uses the time from my mobile phone, it does not need a separate RTC (Real Time Clock), benefitting the size of the smartwatch. I also don\u0026rsquo;t have to replace the battery of RTC. For the Bluetooth module, I used HM-10 clone which is a BLE(Bluetooth Low Energy) module. During the development process, I realized one unfortunate thing. My HM-10 clone ONLY supported BLE. Any legacy Bluetooth connection technology was unsupported. Therefore, I had to create an app just to connect to my device and send information. (I was going to make an app for my smartwatch anyway, but the process of developing an app was a bit harder since there weren\u0026rsquo;t a lot of tutorials on how to connect to a BLE device using Android Studio online.) There is a HM-10 firmware update, which would allow legacy Bluetooth technology, but because I have the clone HM-10, it didn\u0026rsquo;t work. Other than that, I used an 128x64 OLED display (SSD1306), vibrator (vibration motor), a push-button for executing simple task within the watch (turning the screen on when it\u0026rsquo;s in sleep to check time, etc.), a switch to power the device on, an apple watch 4 wrist band/case for the casing and 150mah 3.7v battery for powering the whole device. For the case, I just purchased an Apple Watch (I\u0026rsquo;m not sure what series but the biggest one 140mm xD) case. I had to take the back off, though. My watch was too thick. I had to make my lid, which I did with some cheap fabric (which I got from a dollar store) and I wrapped it around with the electrical tape. I\u0026rsquo;ve already got the time working correctly as well as it notifies me when I receive a notification in my phone (although it doesn\u0026rsquo;t display from which app the notification was sent from, nor the details of the notification). Here\u0026rsquo;s a quick demo of my smartwatch: (yes I know, I changed google accounts several times xD I\u0026rsquo;m JCN) I\u0026rsquo;m still undone with my smartwatch and I\u0026rsquo;ll still improve the software and battery life as it doesn\u0026rsquo;t last long (according to my calculations, around half a week). I\u0026rsquo;m also planning a smartwatch v2, which would use ATTiny85, as the smartwatch I made turned out to be way too \u0026ldquo;fat\u0026rdquo;. Haha. But that won\u0026rsquo;t happen shortly. EDIT: Hey, future me here. This project is discontinued! I was facing a lot of issues during development. They could\u0026rsquo;ve been solved, but that caused me to buy new parts, because while I was putting everything back together after I made some micro-adjustments, I accidentally touched parts that I shouldn\u0026rsquo;t have and physically broke them. I realized I was spending way to much money on a smartwatch project. I was also busy with high school exams and so on and\u0026hellip; to be honest, I was just not motivated enough after that. However, I\u0026rsquo;m considering to bring this project back to life again! I\u0026rsquo;ll post an update when I decide. "],["Project Sketch Hero","2018Âπ¥10Êúà10Êó•","/2018/10/13/project-sketch-hero.html/"," \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; Sketch Hero is my first Unity Android game project that I published to Google Play store which I worked for around a year. Main menu I spent a lot of time developing this game and I\u0026rsquo;m really satisfied with how it turned out. I made this game to see how well I know about Unity. Sketch Hero is an endless runner, which means the player plays the game endlessly while trying to achieve the highest score possible. It\u0026rsquo;s a platformer, where player can interact with the map and needs to go as fast as possible while dodging all the dangerous obstacles. Kind of like temple run, except it\u0026rsquo;s 2D. Player can also draw lines which are colliders for the character inside the game. So basically, you draw and help the character to go as furthest possible. I first got the idea while I was just playing around with Unity game engine. I made a simple drawing system in Unity to learn about different components in Unity. Then, this idea suddenly came into my mind. That\u0026rsquo;s how Sketch Hero was born. The original name was Pocket Runner, but after noticing that this name is too common, I realized not a lot of people are going to find this game on Google Play (there were also an app called Pocket Runner on Google Play already. I didn\u0026rsquo;t want to use the same name for my game.). After a lot of thoughts, I ended up with the name: \u0026ldquo;Sketch Hero\u0026rdquo;. Almost all of the graphics are downloaded from the internet. I BELIEVE they can be used without giving credit. I didn\u0026rsquo;t know/care licensing that much back then. I know for a fact that the assets (like characters) are mostly downloaded from kenney.nl (great website btw) and their asset is CC0, however. Because this is an endless runner, I had to generate terrain procedurally. I didn\u0026rsquo;t want to make the game boring and have the same \u0026ldquo;pieces\u0026rdquo; of the map going (or even worse, same map) over and over again. The solution I used was perlin noise. It\u0026rsquo;s not entirely random noise. Each has some sort of relation to each other and this was just perfect. Because the terrain had to be smooth and not jump around (if this makes sense at all\u0026hellip; they coordinate of the terrain has to be smoothly interpolated between each x value). Now I could\u0026rsquo;ve also used pseudorandom number generator (the \u0026ldquo;normal\u0026rdquo; random number generator) and interpolated with linear interpolation method or something similar, but this would give me too much fluctuation that I can barely control. I first generated different \u0026ldquo;pieces\u0026rdquo; of the map (around 10 x tiles laid down together) using perlin noise. This procedure happened while loading the game, which means before the game starts. For the release version of Pocket Runner, I ended up generating 60 different pieces. I know it\u0026rsquo;s a bit too much, but I didn\u0026rsquo;t want to make the game feel repetitive at all. This was necessary, as generating the map real-time (noise calculations, placement, etc.) was taking up way too much performance on a mobile device. Although the high-end mobile device wasn\u0026rsquo;t bothered by this at all, I was also targeting lower-end smartphones, so optimization was mandatory. Once all the pieces are generated, the game randomly picks a generated piece from pieces array and lays it down in real-time. As the character moves further and further, new pieces gets picked randomly and placed down while the older pieces get disabled (performance reasons). Procedural terrain generation is the feature of the game that I\u0026rsquo;m most proud of. If I look at the code right now, there are still a lot of major changes that I can do to make it cleaner and more efficient. But if it works, hey it works :) I tried to make the UI simple yet can be interacted easily without much effort. I spent a lot of time making them, hopefully, they turned out to be good. I\u0026rsquo;m still bad at making them xD I also made a tutorial for this game (with animations too!), but I\u0026rsquo;m not sure how well this turned out, as some people still didn\u0026rsquo;t know how to \u0026ldquo;properly\u0026rdquo; play the game even after reading the whole tutorial. Some recommended me to do a tutorial within the game, interactively. Perhaps that\u0026rsquo;s something that I should consider in my next game. Tutorial The shop system is also something that I worked on for a long time. It also turned out to be better than I expected. Shop I didn\u0026rsquo;t know how to make a proper settings menu, so this is what I did\u0026hellip; Settings I heard great feedback from the game, overall a very fun experience so I\u0026rsquo;m really happy about this project. Here are some screenshots of the game: Gameplay Gameplay2 Gameplay3 Gameplay4 GameOver (I was NANO Engine back then.) EDIT: Hey, future me here. This project is discontinued! After hearing my game got taken down by Google for \u0026ldquo;violating Google policy\u0026rdquo; (I mean, I understand I used some assets from online, but they were all CC0 which means I was able to use them without giving credit whatsoever. Maybe I understood the licensing incorrectly, I didn\u0026rsquo;t bother too much with licensing back then. I was an inexperienced game developer.), I just didn\u0026rsquo;t want to work on it any further. Without knowing the exact reason why it was violated, I wasn\u0026rsquo;t motivated enough to polish the game, make adjustments and post it again on Google Play. I know I could email Google about the problem and ask what went wrong, but back then, I just wanted to move along. "],["Awaken Sentinel","2017Âπ¥08Êúà08Êó•","/2017/08/10/awaken-sentinel.html/","\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;DISCONTINUED\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; Keep in mind I\u0026rsquo;m writing this a year after I stopped making this game. I didn\u0026rsquo;t bother with portfolio or whatsoever back then. Awaken Sentinel is the first game that I started making seriously on Unity game engine. It\u0026rsquo;s a multiplier FPS with open-world aspects. I can\u0026rsquo;t provide any further information to the game, nor the story, as the whole project started just because I wanted to learn something and I didn\u0026rsquo;t plan on publishing at all/have the finished product. I worked on this game a bit more than a year. I was interested in FPS games back then, so I wanted to create my own FPS game. That\u0026rsquo;s literally how it started. I just wanted to make an FPS game. It took so long for me to make such small progress because I didn\u0026rsquo;t plan anything and I kept changing throughout the development. I changed the concept/theme multiple times. I was also very new to the whole game development. I didn\u0026rsquo;t know where to start/how to start/how to make a successful game. I first started making this game alone by myself, but later when I realized I needed some help I recruited several developers to work on the game with me. I especially needed assistance regarding modeling, animations and sound designs as I had no previous experiences with them. As I already mentioned, I was a newbie in game development when I started making this game. I had ambitious goals (this is something that every starter indie game developers have I believe. They try to replicate their favorite game.) on the game, Awaken Sentinel. Something I learned throughout this game development, which is also something that I will never forget is, never start with big ambitious goals when you\u0026rsquo;re just starting out. I realized this after attempting to create big games 2 - 3 times. It\u0026rsquo;s highly probable that you will lose your motivation quite shortly after. Start with something small, put your hands on the end product of yours. This will get you more motivation to create bigger projects and complete them. However, as I mentioned, Awaken Sentinel was like the first serious game that I was developing. I didn\u0026rsquo;t want to let go after developing for like a couple of months. Awaken Sentinel is formally known as Color Wars. The original idea was that different colored people would fight as a team together, but I ended up discarding this whole concept, as it could be offensive in a certain way. WARNING: Before you continue reading, please note that I was new to the whole game development industry. I didn\u0026rsquo;t know/care much about the copyright and whole licensing. Most of the assets (animations, models, but not scripts/code) that I used on this game are ripped off from another game or downloaded without giving proper credit. I didn\u0026rsquo;t bother that much at that point as I wanted to replace those models with the models that were created by my team back then. I only started taking a screenshot after around half a year later. Early screenshots are not available. FPS mechanics were quite easy for me to understand and implement within Unity. Not only there\u0026rsquo;s a lot of features and functions I could use directly, but there were also a lot of Unity tutorials / well-written documentation I could easily follow. Using those two resources, I managed to create a basic FPS shooter without any problem. Although, Unity was still one of the \u0026ldquo;newer\u0026rdquo; engines back then. FPS tutorials were not that in-depth, to say the least. Tutorials only covered the basics. Any more in-depth complicated functions had to be made purely by myself by looking at the documentation and trying it out. Because this was FPS and I was super excited about the whole multiplayer thing back then, I wanted to integrate the multiplayer system to my game. I did make a successful functional multiplayer functionality using Photon networking (basically, an awesome multiplayer networking solution for different game engines, particularly Unity), but I quickly faced one problem. Resources. Multiplayer means, that there needs to be a host computer that hosts the whole multiplayer server so the clients can communicate with each other through the host. This means, that I would need to have the server of some sort running 24/7. No one wants to sacrifice their computer and host my game\u0026rsquo;s server 24/7. This means I had to buy a server (server is not free\u0026hellip;). It\u0026rsquo;s not a one-time purchase either. I had to pay around 10 dollars per month (this was the cheapest plan). But here\u0026rsquo;s the thing: is it worth it for me to spend 10 dollars per month on a server for a game that no one knows about and it\u0026rsquo;s not even released? I ended up not buying a server at all. This also contributed to the end of this game development. MultiplayerDemo (The character is t-posing because the animation synchronization was still in progress. I just noticed the character looks small\u0026hellip;) I also made a login system using \u0026ldquo;Database Control (Free)\u0026rdquo; which I downloaded through Unity\u0026rsquo;s asset store. It was a free solution for me to create a login database system. This, however, does not have any encryption to the database whatsoever, meaning that there\u0026rsquo;s a high risk of it getting hacked/leaked to the public. I wasn\u0026rsquo;t concerned about the whole security part, though. I eventually wanted to upgrade it to a more safer solution once I earn some money through the game I published. MultiplayerLogin After developing for some while, I wanted to work on the graphical side of the game. At the very beginning, without any post-processing and proper lighting setup, this is how the game looked like: Before After proper lighting configuration and post-processing, this is how it looked: After After2 I know there are still a lot of major issues with the lighting and post-processing configs. Especially the vignette that\u0026rsquo;s so extreme. Anti-aliasing on the text \u0026ldquo;Fall Damage\u0026rdquo; as well as on the trees can be improved significantly. NOTE: Following screenshots and video is taken BEFORE the graphics update. One feature I made that I was proud of was real-time scope. In case you don\u0026rsquo;t know what this is, here\u0026rsquo;s how it looks like: RealTimeScope Unlike traditional UI overlay scope, this real-time scope must be done by having two separate cameras, one drawing the scope (lower FOV) while the other drawing the regular view. Because there have to be two cameras rendering the scene, the performance cost was a bit extreme. I also added some post-processing effects to make the effect look more dramatic. Here\u0026rsquo;s a youtube video I made on NANO Engine channel (my old channel) to demonstrate the game better. There has been a lot of updates after the update, though (things like graphics update, launcher update, which I\u0026rsquo;ll discuss later.). P (Yes the game was still called project color wars.) As you might notice in the video, UI looks very odd and doesn\u0026rsquo;t fit the game. This is something that I started taking more seriously after discontinuing this game. I also featured recoil in the showcase video. However, because I never tried making a recoil system before, the recoil system that I used for this game was hard-coded. Meaning it wasn\u0026rsquo;t dynamic and written in a clean code at all. It might\u0026rsquo;ve looked good on the outside, but if I want to make any changes/minor adjustments to the recoil pattern, I would have to re-write the entire code again. Here are some more gameplay screenshots: Gameplay Gameplay2 Other than that, I also made a launcher for this game. Game launcher checks for the latest update and updates the game if a newer version is available. It also prevented players to play with the older version. This was required to fix critical exploits that ruin the multiplayer experience. Game launcher checks for the latest update by accessing the publicly available text document which stores the latest version data. This text document is stored on a cloud hosting service, in my case, I used one drive. I originally wanted to go with google drive, but google drive didn\u0026rsquo;t work out as I couldn\u0026rsquo;t get the direct link to the file. The launcher then compares the fetched version code with the version code of the game. If they\u0026rsquo;re different in any way, it updates the game by fetching the newest version of the game, which is also hosted on a publicly available cloud storage service. Although this might sound like an optimal solution, there\u0026rsquo;s a problem. It is technically possible to decompile the game and manually change the version code of the game to match the latest version code. This allows the user to avoid the update. launcher "]]